OpenXC Android Library
=========================

This library is a part of the [OpenXC][] project.

## Description

This Android library contains the tools required to read vehicle data from the
vehicle's CAN bus through the OpenXC CAN translation module in any Android
application..

## Installation

This project declares dependencies with Maven - you can choose to use the
project via Eclipse, via the command line, or both ways simultaneously.

### Using Eclipse

* Install [Eclipse](http://www.eclipse.org/downloads/) Indigo or later for Java
  Developers. Other versions do not install Maven, which is required.
* Install the [Android SDK](http://developer.android.com/sdk/index.html) and
  then the [ADT plugin](http://developer.android.com/sdk/eclipse-adt.html)
  from Google.
* Clone the [openxc-android][] repo (this repo).
* Open Eclipse and go to `File -> Import -> Maven -> Existing Maven Projects`.
  Browse to where you cloned the repository and import the `openxc` project.
* You will be prompted to install the m2e-android connector - do that, then
  restart Eclipse.
* Right click on the `openxc` project, go to Maven -> Update Project
  Configuration. Select the `openxc` project in the dialog and click OK.
* Start a new Android project for your application if you haven't already.
* Right click on your project and go to `Build Path -> Configure Build Path`.
    Click the `Projects` tab and add a reference to the `openxc` project.
* There should be no changes in the repository at this point (`git status`
  should report nothing) and there should be no errors in Eclipse.


### Using the Command Line

If you prefer to compile and deploy from the command line, you can use Maven
without Eclipse.

* Install [Maven](http://maven.apache.org/) - it's just a Java application, so
  "installation" can be as simple as extracting the download and making sure the
  `mvn` executable is somewhere on your shell's `PATH`.
* Follow the instructions in the "Android SDK and Maven" section of this
  document to install the latest version of the Android SDK for Maven
* Clone the [openxc-android][] repo (this repo).
* Run `mvn install -p openxc` from the `openxc` directory to package and install
  the `openxc` library to your local Maven repository.
* Start a new Android project if you haven't already (check out the
  `example/pom.xml` if you're unfamiliar with setting up a Maven project) and
  make sure the `openxc` dependency is declared like so:

    <dependencies>
        <dependency>
            <groupId>com.openxc</groupId>
            <artifactId>openxc</artifactId>
            <version>1.0.0</version>
            <type>apklib</type>
        </dependency>
    </dependencies>

[openxc-android]: https://github.com/openxc/openxc-android

### Android Manifest

The OpenXC services must be defined in your application's `AndroidManifest.xml`
before using them. Add this inside the `<application>` tag:

      <service android:name="com.openxc.VehicleService"/>
      <service android:name="com.openxc.remote.RemoteVehicleService" android:process=":remote">
          <intent-filter>
              <action android:name="com.openxc.remote.RemoteVehicleServiceInterface" />
          </intent-filter>
      </service>

You must also specify that your application uses the USB host feature (inside
the `<application>` tag):

      <uses-feature android:name="android.hardware.usb.host"
              android:required="true" />

### USB Device Filter

If you want your application to refresh the vehicle interface when the USB CAN
translator is plugged in, you must include an XML file defining a USB device
filter. Save this XML to `res/xml/device_filter.xml`:

    <?xml version="1.0" encoding="utf-8"?>
    <resources>
        <usb-device vendor-id="1240" />
    </resources>

and in the `AndroidManifest.xml`:

      <activity android:name="com.openxc.remote.sources.usb.UsbDeviceAttachmentActivity">
            <intent-filter>
                <action android:name="android.hardware.usb.action.USB_DEVICE_ATTACHED" />
            </intent-filter>

            <meta-data android:name="android.hardware.usb.action.USB_DEVICE_ATTACHED"
                    android:resource="@xml/device_filter" />
      </activity>

## Usage

Vehicle measurements are accessed through an [Android service][services]. Your
application connects to the service using the Android Interface Definition
Language ([AIDL][]) - check out the Architecture section for more details.

### Service Binding

You must first [bind with the VehicleService][binding] before you can receive
any vehicle data.

Request to bind with the service in the normal fashion:

    Intent intent = new Intent(this, VehicleService.class);
    bindService(intent, mConnection, Context.BIND_AUTO_CREATE);

Then, in your `onServiceConnected()` grab the service handle and cast it to the
correct type:

    VehcileService vehicleService;
    private ServiceConnection mConnection = new ServiceConnection() {
        // Called when the connection with the service is established
        public void onServiceConnected(ComponentName className, IBinder service) {
            vehicleService = ((VehicleService.VehicleServiceBinder)
                    service).getService();
        }

        // Called when the connection with the service disconnects unexpectedly
        public void onServiceDisconnected(ComponentName className) {
            vehicleService = null;
        }
    };

### Synchronous

Once the service is bound and you have a connection to it in your activity, you
can receive measurements on demand (i.e. synchronously).

    VehicleSpeed measurement = vehicleService.get(VehicleSpeed.class);

### Asynchronous

If you need to be kept up-to-date on any vehicle measurement, you can also
register with the service to be notified of updates.

    VehicleSpeed.Listener listener = new VehicleSpeed.Listener() {
        public void receive(VehicleMeasurement measurement) {
            final VehicleSpeed speed = (VehicleSpeed) measurement;
            if(!speed.isNone()) {
                // do stuff with the measurement
            }
        }
    };
    vehicleService.addListener(VehicleSpeed.class, listener);

### Measurements

You've probably noticed that vehicle data is returned encapsulated in an object.
In the examples above, we used the `VehicleSpeed` measurement. All of the data
types supported by OpenXC are provided as children of the `Measurement` class.

The parent class provides a standard interface for all measurements, starting
with a way to retrieve its value:

    vehicleService.get(VehicleSpeed.class);

Occasionally a measurement will not have been received from the CAN translator
yet - it could be a malfunction, or you're just checking too early for an
infrequently updated measurement:

    VehicleSpeed measurement = vehicleService.get(VehicleSpeed.class);
    if(measurement.isNone()) {
        // do stuff with it
    }

You can check the age of a measurement to determine how long ago the state was
actually reflected in the physical vehicle:

    VehicleSpeed measurement = vehicleService.get(VehicleSpeed.class);
    if(measurement.getAge() < 10) {
        // only if age is less than 10 seconds
    }

The range of every measurement is defined in the class, and can be queried
programmatically if you need to figure out your the current value's relative
position:

    range = measurement.getRange();
    int percentage = measurement.getValue() / range;

## Testing

### Button Events

Unfortunately the Android emulator does not allow us to send arbitrary events
from button presses without editing the source. In order to test your button
event handlers, the recommended method it to write them in such a way that they
can accept either VehicleButtonEvents or regular Android key events as input.
You may want a flag to disable the Android key events when running in
production.

### Emulated Vehicle Measurements

The library ships with a method for playing back previously recorded vehicle
measurement trace files for testing. The `VehicleMeasurement` objects received
by your application are identical to those received from a live vehicle.

The trace file format is simply a plain text file of OpenXC JSON messages
separated by newlines, e.g.:

    {"name": "vehicle_speed", "value": 42}
    {"name": "windshield_wiper_speed", "value": 11}
    {"name": "steering_wheel_angle", "value": 94.1}
    {"name": "transmission_gear_position", "value": "FIRST"}

In fact, this is the same method used by some of the instrumentation tests. Once
you've created a file either by recording the output of the CAN translator
module or building one by hand, add it to your testing application's raw
resources (`yourapp/res/raw/yourtrace`). When binding with the
`VehicleService`, specify the type of data source and your trace file:

        Intent startIntent = new Intent();
        startIntent.setClass(getContext(), VehicleService.class);
        startIntent.putExtra(RemoteVehicleService.DATA_SOURCE_NAME_EXTRA,
                TraceVehicleDataSource.class.getName());
        startIntent.putExtra(RemoteVehicleService.DATA_SOURCE_RESOURCE_EXTRA,
                "resource://" + R.raw.yourtrace);
        service = ((VehicleService.VehicleServiceBinder)
                bindService(startIntent)).getService();
        service.waitUntilBound();

The final `service.waitUntilBound()` line is optional - it causes the thread to
block until the service is ready to start playing back the trace - but can be
useful for testing when you need to make sure you will get a measurement back
from the system.

## Android SDK and Maven

The most recent version of the Android SDK currently available in the central
Maven repository is 2.3. You'll need to install a more recent version in your
own local repository.

The recommended method is using the
[maven-android-sdk-deployer](https://github.com/mosabua/maven-android-sdk-deployer).
All you should need is to set the `ANDROID_HOME` environment variable (see the
project's README for more details) and run:

    $ mvn install -P 3.1

If you have a remote Maven repository you share with others, I'm sure they would
thank you if you uploaded the resulting files - that way, nobody needs to do
this part.

## Contributing

Contributions are welcome - please file issues if you find any bugs. If you're
working on a bug fix, there is a test suite you can use to confirm your fix
doesn't break anything else.

To compile and run the test suite on a connected Android device:

    openxc-android/ $ mvn clean install

NOTE: This is also possible from Eclipse directly, I just haven't done it
myself. If you want to do it and add to this documentation, you're more than
welcome.

This will:

* Clean up any existing compiled files
* Compile, test and package the openxc apklib, and install it to your local
  Maven repository (usually `~/.m2/repository`)
* Compile and package the openxc-it integration test apk using the version
  of the openxc library that you just built.
* Re-install the openxc-it package to the connected Android device (either
  an emulator or tablet).
* Run the instrumentation tests in the openxc-it package on the device

Fire up Eclipse and the DDMS perspective (a part of the Eclipse ADT from
Google), find the openxc process in the list (it should have a red bug next to
it) and click the green bug icon to start debugging the process. Once you've
enabled debugging once, it should do so automatically each time you run the
tests for this Eclipse session.

If you want the tests to wait for a debugger to attach, change the `testDebug`
setting in `openxc-android/pom.xml` to `false`.

To deploy the examples to a device:

    $ mvn android:deploy -Dandroid.file=examples/target/openxc-examples.apk

## License

Copyright (c) 2011 Ford Motor Company
Licensed under the [Apache License, Version 2.0][apache]

[apache]: http://www.apache.org/licenses/LICENSE-2.0.html
[binding]: http://developer.android.com/guide/topics/fundamentals/bound-services.html#Binding)
[services]: http://developer.android.com/guide/topics/fundamentals/services.html
[AIDL]: http://developer.android.com/guide/developing/tools/aidl.html
[OpenXC]: http://openxcplatform.com
